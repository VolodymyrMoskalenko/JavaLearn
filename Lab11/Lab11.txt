1. Чим інтерфейс Set відрізняється від інтерфейсу Collection?
Collection - базовий інтерфейс для всіх коллекцій і інщих інтерфейсів колекцій.
Set розширює інтерфейс Collection і використовується для зберігання множини унікальних об’єктів і не реалізує порядок елементів.
Set використовує equlas method для перевірки дублікатів.
Інтерфейс Collection є узагальненим і розширює інтерфейс Iterable, тому всі об'єкти колекцій можна перебирати в циклі по типу for-each.

Серед методів інтерфейсу Collection можна виділити наступні:

boolean add (E item): додає в колекцію об'єкт item. При вдалому додаванні повертає true, після невдалої спроби здійснити - false

boolean addAll (Collection <? extends E> col): додає в колекцію все елементи з колекції col. При вдалому додаванні повертає true, після невдалої спроби здійснити - false

void clear (): видаляє всі елементи з колекції

boolean contains (Object item): повертає true, якщо об'єкт item міститься в колекції, інакше повертає false

boolean isEmpty (): повертає true, якщо колекція порожня, інакше повертає false

Iterator <E> iterator (): повертає об'єкт Iterator для обходу елементів колекції

boolean remove (Object item): повертає true, якщо об'єкт item вдало видалений з колекції, інакше повертається false

boolean removeAll (Collection <?> col): видаляє всі об'єкти колекції col з поточної колекції. Якщо поточна колекція змінилася, повертає true, інакше повертається false

boolean retainAll (Collection <?> col): видаляє всі об'єкти з поточної колекції, крім тих, які містяться в колекції col. Якщо поточна колекція після видалення змінилася, повертає true, інакше повертається false

int size (): повертає число елементів в колекції

Object [] toArray (): повертає масив, що містить всі елементи колекції

Всі ці та інші методи, які є в інтерфейсі Collection, реалізуються усіма колекціями, тому в цілому загальні принципи роботи з колекціями будуть одні і ті ж.
Однаковий інтерфейс спрощує розуміння і роботу з різними типами колекцій. Так, додавання елемента буде проводитися за допомогою методу add, який приймає для додавання в якості параметра. 
Для видалення викликається метод remove (). Метод clear буде очищати колекцію, а метод size повертати кількість елементів в колекції.

2. Чим множина(array) відрізняється від списку(list)?
Array vs ArrayList in Java
1) Основа різниця між Array та ArrayList in Java це що Array це фіксованого розміру структура данних, поки ArrayList змінної довжини Collection class.
 Не можна змінити довжини Array колись створенного в Java , але ArrayList змінює розмір самого себе, коли заповнюється в залежності від capacity and load factor. 
Оскільки ArrayList внутрішньо підтримується Array в Java, будь-яка операція зміни розміру в ArrayList сповільнить продуктивність,
 оскільки це передбачає створення нового масиву та копіювання вмісту зі старого масиву в новий масив.

2) Ще одна відмінність Array від ArrayList на Java полягає в тому, що ви не можете використовувати Generics разом із Array,
оскільки екземпляр Array знає про те, який тип він може містити, і викидає ArrayStoreException, якщо ви намагаєтесь зберегти тип, який не перетворюється у тип Array.
  ArrayList дозволяє використовувати Generics для забезпечення безпеки типу.

3) Ви також можете порівняти Array проти ArrayList за тим, як обчислити довжину масиву або розмір ArrayList.
Усі види Array надають змінну довжини, яка позначає довжину Array, тоді як ArrayList надає метод size () 
для обчислення розміру ArrayList на Java.

4) Ще одна основна відмінність ArrayList від Array полягає в тому, що ви не можете зберігати примітиви 
в ArrayList, вони можуть містити лише об'єкти.
  У той час як Array може містити як примітиви, так і об'єкти на Java.
  Хоча Автобоксинг Java 5 може створити враження про зберігання примітивів у ArrayList, він фактично 
автоматично перетворює примітиви в Object. наприклад
ArrayList<Integer> integerList = new ArrayList<Integer>();
integerList.add(1); //here we are not storing primitive in ArrayList, instead autoboxing will convert int primitive to Integer object

5) Java пропонує метод add () для вставки елемента в ArrayList, і ви можете просто використовувати
 оператор призначення для зберігання елемента в масиві, наприклад
   Для зберігання Об'єкта у вказаній позиції використовуйте

Object [] objArray =  new Object[10];
objArray [1] =  new Object();

6) Ще одна різниця в Array vs ArrayList полягає в тому, що ви можете створювати екземпляр ArrayList,
 не вказуючи розмір, Java створить список масивів з розміром за замовчуванням, але обов'язковим є 
 надання розміру масиву, створюючи прямо чи опосередковано, ініціалізуючи масив під час його створення.
  До речі, ви також можете ініціалізувати ArrayList під час його створення.

3. Які є переваги/недоліки використання множин(array) у порівнянні зі списками(list)?
Масив - це сукупність однотипних даних, розташованих безперервно в пам'яті. Доступ до елементу 
здійснюється за індексом за O (1) - ми звертаємося безпосередньо до потрібної ділянки пам'яті.
Доступ до елементу в зв'язковому списку в середньому займає O (N) шляхом перебору елементів в пошуках 
потрібного.Плюси масивів, якщо ви часто звертаєтесь і бігаєте по колекції елементів, то масиви забезпечать
вам максимальну продуктивність тільки за рахунок індексної адресації і меньшої кількості кеш-міксів.
Мінуси, це фіксований розмір, збільшити можна, але це дорого і довго в плані продуктивності.
В  списку легко додавати та видаляти елементи, мінуси - елементи створені в різний час можуть виявитися
в памяті в різних місцях, що може призвести до великої кількості кеш-міксів.Траверсінг по списку банально
повільніший. 
	-            													 Масиви 																								List

Зміна розміру 													 немає 																			     		 				да

Складність доступу до елементу 						    		завжди O (1) 																						залежить від реалізації List

Підтримка семантики	                 	"тільки для читання" немає (варіант обходу в простих випадках: клонування масиву)       		 				так (з використанням read-only-декоратора Collections.unmodifiableList (List))

"Рівна" інтеграція в систему типів 		 немає (масиви є свого роду особливим випадком організації об'єктів; на відміну від             	   						                  так 
											.NET не має ніякого array-типу в якості базового типу) 

Підтримка примітивних типів                                      так 																						ні ( "важкі" об'єкти для примітивів; злегка нівелюється наявністю 
																																					factory-методів типу Integer.valueOf (int); варіант обходу: FastUtils або Trove)

Перевірка типу привласнюються об'єктів   в момент присвоювання елементу масиву або його ініціалізації                       					 в момент витягування елемента списку та інтерпретації його на стороні, яка використовує список

Взаємні перетворення               масив зі списку: List.toArray () завжди повертає новий масив об'єктів типу Object;           				  список з масиву: Arrays.asList (T ...) без проблем, якщо масив є масивом об'єктів,
									List.toArray (T []) дозволяє вказати приготований буфер для не-примітивів;                    					 а не примітивних типів; якщо масив є масивом примітивів, Arrays.asList () повертає список
									перетворення в масив примітивів не підтримує безпосередньо                            						  з одного елемента, вважаючи вхідний масив єдиним об'єктом, хоча існують варіанти типу
									Ints.asList (int []) з Guava

Можливість дізнатися загальний тип всіх елементів               так                                                        							ні (через стирання типів; можна дізнатися тип елемента тільки по-окремо при доступі до кожного елементу)

.toString () - уявлення                          немає (завжди має вигляд "[T @ IDENTITY", де T - тип масиву, IDENTITY - унікальний ID об'єкта;    так (залежить від реалізації, в загальному випадку "[n1 , n2, n3 ...] ")
																потрібне використання Arrays.toString ()) 
Реалізація for-обходу                                        через лічильник для доступу до кожного елементу                                                 через итератор за допомогою реалізації Iterable

4. Чим інтерфейс SortedSet відрізняється від Set?
Цей інтерфейс розширює Set і забезпечує повне впорядкування його елементів.
 Прикладом класу, який реалізує цей інтерфейс, є TreeSet.

5. Чому в назві класу TreeSet є слово Tree? 


6. Якими критеріям мають відповідати об’єкти для того, щоб посилання на них можна було зберігати у TreeSet?


7. Чому в TreeSet не слід зберігати посилання на мутабельні об’єкти?
