1.Патерн проектування — це типовий спосіб вирішення певної проблеми, що часто зустрічається при проектуванні архітектури програм.
На відміну від готових функцій чи бібліотек, патерн не можна просто взяти й скопіювати в програму. Патерн являє собою не якийсь конкретний код, а загальний принцип вирішення певної проблеми, який майже завжди треба підлаштовувати для потреб тієї чи іншої програми.
Патерни часто плутають з алгоритмами, адже обидва поняття описують типові рішення відомих проблем. Але якщо алгоритм — це чіткий набір дій, то патерн — це високорівневий опис рішення, реалізація якого може відрізнятися у двох різних програмах.

2. Стратегія — це поведінковий патерн проектування, який визначає сімейство схожих алгоритмів і розміщує кожен з них у власному класі. Після цього алгоритми можна заміняти один на інший прямо під час виконання програми.
https://refactoring.guru/uk/design-patterns/strategy

3.SOLID — це абревіатура складена з перших літер п'яти базових принципів об'єктно-орієнтованого програмування та дизайну запропонована Робертом Мартіном.
S	SRP	
Принцип єдиного обов'язку (Single responsibility principle): Кожен об'єкт має виконувати лише один обов'язок.

O	OCP	
Принцип відкритості/закритості (Open/closed principle): Програмні сутності повинні бути відкритими для розширення, але закритими для змін. Розширення певного класу/інтерфейсу може здійснюватись через його успадкування.

L	LSP	
Принцип підстановки Лісков (Liskov substitution principle): Об'єкти в програмі можуть бути заміненими їх нащадками без зміни коду програми.

I	ISP	
Принцип розділення інтерфейсу (Interface segregation principle): Багато спеціалізованих інтерфейсів краще за один універсальний. Інтерфейс може бути поділений на спеціалізовані ще на стадії проектування, заради майбутньої гнучкості програмних компонентів.

D	DIP	
Принцип інверсії залежностей (Dependency inversion principle): Залежності всередині системи будуються на основі абстракцій, що не повинні залежати від деталей; навпаки, деталі мають залежати від абстракцій. Модулі вищих рівнів не мають залежати від модулів нижчих рівнів.

4. Принцип єдиного обов'язку (Single responsibility principle):
Кожен обєкт повинен бути відповідальний за вирішення однієї проблеми.
class Animal {
    constructor(name: string){}
    getAnimalName(){}
    saveAnimalName() {}
}

Цей клас порушує цей принцип, так як один клас має вирішувати одну задачу.
Він же вирішує дві: займається роботою з зберіганням данних в методі saveAnimal та маніпулючи властивостями обєкта в конструкторі і в методі getAnimalName.
Якщо змінниться порядок роботи з базою данних, що використовує застосунок, то прийдеться вносити зміни в усі класи, що працюють з базою. Одні підсистеми можуть зачепити інші.
Щоб вирішити цю проблему необхідно створити ще один клас, що буде працювати з базою та зберігати обєкти класу Animal
class Animal {
    constructor(name: string){}
    getAnimalName(){}
}
class AnimalDB {
    getAnimal(a: Animal){}
    saveAnimal(a : Animal) {}
}
Проектуючи класи, ми повинні прагнути до того щоб обєднувати ті компоненти, в яких зміни відбуваються по одним і тим самим причинам і навпаки.

Принцип відкритості/закритості (Open/closed principle):
class Animal {
    constructor(name: string){}
    getAnimalName(){}
}
Ми хочемо перебрати список тварин, кожне з яких представлено обєктов класу Animal і дізнатись які звуки вони видають.
//..
const animals: Array<Animal> = [
    new Animal('lion'),
    new Animal('mouse')
];
function AnimalSound(a: Array<Animal>) {
    for(int i = 0; i <= a.length; i++){
    if(a[i].name == 'lion')
        return 'roar';    
    if(a[i].name == 'mouse')
        return 'squeak';
    }
}

AnimalSound(animals);
Найбільша проблема в тому, що функція визначає то, який звук видає та чи інша тварина, аналізучи конкретні обєкти.Функція AnimalSound не відповідає принципу відкритості-закритості, так як, наприклад, при появі нових видів тварин, нам, для того, щоб з її допомогою можна було б дізнаватися звуки, що видаються ними, доведеться її змінити.При додаванні в масив нової тварини доведеться доповнювати код функції. Приклад це дуже простий, але якщо подібна архітектура використовується в реальному проекті, функцію доведеться постійно розширювати, додаючи в неї нові вирази if.
Вирішення проблеми:
class Animal{
    makeSound();
//..
}

class Lion extends Animal {
    makeSound(){
        return 'roar';
    }
}

class Squirrel extends Animal {
    makeSound() {
        return 'squeak';
    }
}

function AnimalSound(a: Array<Animal>) {
    for(int i = 0; i <= a.length; i++){
        a[i].makeSound();
    }
}
(
AnimalSound(animals);


У класу Animal тепер є віртуальний метод makeSound. При такому підході потрібно, щоб класи, призначені для опису конкретних тварин, розширювали б клас Animal і реалізовували б цей метод.
В результаті у кожного класу, що описує тваринного, буде власний метод makeSound, а при переборі масиву з тваринами в функції AnimalSound досить буде викликати цей метод для кожного елемента масиву.Якщо тепер додати в масив об'єкт, що описує нова тварина, функцію AnimalSound змінювати не треба.

Принцип підстановки Лісков (Liskov substitution principle):
Мета цього принципу полягають в тому, щоб класи-спадкоємці могли б використовуватися замість батьківських класів, від яких вони утворені, не порушуючи роботу програми. Якщо виявляється, що в коді перевіряється тип класу, значить принцип підстановки порушується.
Розглянемо застосування цього принципу, повернувшись до прикладу з класом Animal. Напишемо функцію, призначену для повернення інформації про кількість кінцівок тварини.
function AnimalLegCount(a: Array<Animal>) {
    for(int i = 0; i <= a.length; i++) {
        if(typeof a[i] == Lion)
            return LionLegCount(a[i]);
        if(typeof a[i] == Mouse)
            return MonuseLegCount(a[i]);
    }                                                                                                           
}
AnimalLegCount(animals);
Функція порушує принцип підстановки (і принцип відкритості-закритості). Цей код повинен знати про типи всіх оброблюваних їм об'єктів і, в залежності від типу, звертатися до відповідної функції для підрахунку кінцівок конкретного тваринного. Як результат, при створенні нового типу тваринного функцію доведеться переписувати.

Для того щоб ця функція не порушувала принцип підстановки, перетворимо її з використанням вимог, сформульованих Стівом Фентоном. Вони полягають в тому, що методи, які беруть або повертають значення з типом якогось суперкласу (Animal в нашому випадку) повинні також приймати і повертати значення, типами яких є його підкласи (Pigeon).
function AnimalLegCount(a: Array<Animal>) {
    for(int i = 0; i <= a.length; i++) {
        a[i].LegCount();
        }                                                                                                           
}
AnimalLegCount(animals);


Тепер ця функція не цікавиться типами переданих їй об'єктів. Вона просто викликає їх методи LegCount. Все, що вона знає про типах - це те, що оброблювані їй об'єкти повинні належати класу Animal або його подклассам.
Тепер в класі Animal повинен з'явитися метод LegCount.А його підкласам слід реалізувати цей метод.
Внаслідок, наприклад, при зверненні до методу LegCount для екземпляра класу Lion здійснюється виклик методу, реалізованого в цьому класі, і повертається саме те, що можна очікувати від виклику подібного методу.
Тепер функції AnimalLegCount не потрібно знати про те, об'єкт якого саме підкласу класу Animal вона обробляє для того, щоб дізнатися відомості про кількість кінцівок у тварини, представленого цим об'єктом. Функція просто викликає метод LegCount класу Animal, так як підкласи цього класу повинні реалізовувати цей метод для того, щоб їх можна було б використовувати замість нього, не порушуючи правильність роботи програми.

Принцип розділення інтерфейсу (Interface segregation principle):
interface Shape {
    drawCircle();
    drawSquare();
    drawRectangle();
}
Він використовує методи малювання кіл (drawCircle), квадратів (drawSquare) і прямокутників (drawRectangle). Всі ці геометричні фігури, такі як коло (коло), квадрат (квадрат) і прямокутник (прямокутник), повинні містити в собі застосування всіх цих методів. 
Наприклад, клас Rectangle, що представляє прямокутник, реалізує методи (drawCircle і drawSquare), які йому абсолютно не потрібні. Те ж саме можна помітити і при аналізі коду двох інших класів.
Припустимо, ми вирішимо додати в інтерфейс Shape ще один метод, drawTriangle, призначений для малювання трикутників.
Це призведе до того, що класів, які представляють конкретні геометричні фігури, доведеться реалізовувати ще і метод drawTriangle. В іншому випадку виникне помилка.
Як видно, при такому підході неможливо створити клас, який реалізує метод для виведення кола, але не реалізує методи для виведення квадрата, прямокутника і трикутника. Такі методи можна реалізувати так, щоб при їх виведенні викидалася б помилка, яка вказує на те, що подібну операцію виконати неможливо.
Принцип поділу інтерфейсу застерігає нас від створення інтерфейсів, подібних Shape з нашого прикладу. Клієнти (у нас це класи Circle, Square і Rectangle) не повинні реалізовувати методи, які їм не потрібно використовувати. Крім того, цей принцип вказує на те, що інтерфейс повинен вирішувати лише якусь одну задачу (в цьому він схожий на принцип єдиної відповідальності), тому все, що виходить за рамки цього завдання, має бути винесено в інший інтерфейс або інтерфейси.
У нашому ж випадку інтерфейс Shape вирішує завдання, для вирішення яких необхідно створити окремі інтерфейси. Дотримуючись цієї ідеї, переробимо код, створивши окремі інтерфейси для вирішення різних вузькоспеціалізованих завдань:
interface Shape {
    draw();
}
interface ICircle {
    drawCircle();
}
interface ISquare {
    drawSquare();
}
//...
class Circle implements ICircle {
    drawCircle() {
        //..
    }
}
// ... 
Тепер інтерфейс ICircle використовується лише для малювання кіл, так само як і інші спеціалізовані інтерфейси - для малювання інших фігур. Інтерфейс Shape може застосовуватися в якості універсального інтерфейсу.

Принцип інверсії залежностей (Dependency inversion principle):
Модулі верхніх рівнів не повинні залежати від модулів нижніх рівнів. Обидва типи модулів повинні залежати від абстракцій.
Абстракції не повинні залежати від деталей. Деталі повинні залежати від абстракцій.
В процесі розробки програмного забезпечення існує момент, коли функціонал додатка перестає поміщатися в рамках одного модуля. Коли це відбувається, нам доводиться вирішувати проблему залежностей модулів. В результаті, наприклад, може виявитися так, що високорівневі компоненти залежать від низькорівневих компонентів.
class XMLHttpService extends XMLHttpRequestService {}

class Http {
    constructor(private xmlhttpService: XMLHttpService) {}
    get( url: string, options:any){
        this.xmlhttpService.request(url,'GET');
    }
    post(){
        this.xmlhttpService.request(url,'POST');
    }
}

Тут клас Http є високорівнева компонент, а XMLHttpService - низькорівневий. Така архітектура порушує пункт A принципу інверсії залежностей: «Модулі верхніх рівнів не повинні залежати від модулів нижніх рівнів. Обидва типи модулів повинні залежати від абстракцій ».
Клас Http вимушено залежить від класу XMLHttpService. Якщо ми вирішимо змінити механізм, який використовується класом Http для взаємодії з мережею - скажімо, це буде Node.js-сервіс або, наприклад, сервіс-заглушка, застосовуваний для цілей тестування, нам доведеться відредагувати всі екземпляри класу Http, змінивши відповідний код. Це порушує принцип відкритості-закритості.
Клас Http не повинен знати про те, що саме використовується для організації мережевого з'єднання. Тому ми створимо інтерфейс Connection:
interface Connection{
    request(url: string, opts:any);
}
Інтерфейс Connection містить опис методу request і ми передаємо класу Http аргумент типу Connection:
class Http {
    constructor(private httpConnection: Connection) {}
    get( url: string, options:any){
        this.xmlhttpService.request(url,'GET');
    }
    post(){
        this.xmlhttpService.request(url,'POST');
    }
}

Тепер, незалежно від того, що саме використовується для організації взаємодії з мережею, клас Http може користуватися тим, що йому передали, не піклуючись про те, що ховається за інтерфейсом Connection.
Перепишемо клас XMLHttpService таким чином, щоб він реалізовував цей інтерфейс:
class XMLHttpService implements Connection {
    const xhr = new XMLHttpRequest();
//..

    requesr(url:string, opts:any) {
        xhr.open();
        xhr.send();
}
В результаті ми можемо створити безліч класів, що реалізують інтерфейс Connection і підходять для використання в класі Http для організації обміну даними по мережі.

Як можна помітити, тут високорівневі і низькорівневі модулі залежать від абстракцій. Клас Http (високорівнева модуль) залежить від інтерфейсу Connection (абстракція). Класи XMLHttpService, NodeHttpService і MockHttpService (низькорівневі модулі) також залежать від інтерфейсу Connection.
Крім того, варто відзначити, що дотримуючись принципу інверсії залежностей, ми дотримуємося і принцип підстановки Барбари Лісков. А саме, виявляється, що типи XMLHttpService, NodeHttpService і MockHttpService можуть служити заміною базового типу Connection.

5.Компонент є основним об'єктом інтерфейсу користувача на Java. Все, що ви бачите на дисплеї в додатку Java, є компонентом. Сюди входять такі речі, як вікна, панелі, кнопки, прапорці, смуги прокрутки, списки, меню та текстові поля. Для використання компонент зазвичай повинен бути поміщений в контейнер. Об'єкти контейнерів групують компоненти, упорядковують їх для відображення за допомогою диспетчера макетів та асоціюють їх із певним пристроєм відображення.
Введення залежності - це поняття, що діє для будь-якої мови програмування. ... Згідно з цією концепцією клас не повинен налаштовувати свої залежності статично, а повинен бути налаштований зовні. Клас Java має залежність від іншого класу, якщо він використовує екземпляр цього класу. Ми називаємо це залежністю _класу.

6.Якщо вашим класам потрібні інші класи для виконання своїх операцій, ці інші класи - це залежності. ... Явні залежності найчастіше з'являються в конструкторі об'єкта, для класових залежностей або в списку параметрів певного методу для більш локальних залежностей.
Методи та класи повинні явно вимагати (як правило, через параметри методу чи параметри конструктора) будь-які об'єкти, що співпрацюють, які їм потрібні для правильної роботи.

7.Якщо вашим класам потрібні інші класи для виконання своїх операцій, ці інші класи - це залежності. Ці залежності є неявними, якщо вони існують лише в коді вашого класу, а не в його загальнодоступному інтерфейсі. Явні залежності найчастіше з'являються в конструкторі об'єкта, для класових залежностей або в списку параметрів певного методу для більшої кількості локальних залежностей.

Класи з неявними залежностями специфічниші, ніж класи з явними залежностями. Їх складніше перевірити, оскільки вони більш щільно з'єднані зі своїми співробітниками. Їх складніше проаналізувати на побічні ефекти, тому що в кодовій базі всього класу потрібно шукати об'єкти або виклики статичних методів. Вони більш крихкі і щільніше поєднуються зі своїми співучасниками, що призводить до більш жорстких і крихких конструкцій.

Класи з явними залежностями більш чесні. Вони дуже чітко заявляють, що їм потрібно для виконання певної функції. Вони схильні дотримуватися принципу найменшого сюрпризу, не впливаючи на частини програми, які вони явно не демонстрували, що потрібно впливати. Явні залежності можна легко замінити іншими реалізаціями, як у виробництві, так і під час тестування чи налагодження. Це робить їх набагато легшими в обслуговуванні та набагато відкритішими до змін.

8.Зв'язок і повязаність - це терміни, які зустрічаються разом дуже часто. Звязок посилається на взаємозалежності між модулями, тоді як повязаність описує, наскільки пов'язані функції в одному модулі.
Повязаність - це ступінь (якість), на який компонент / модуль зосереджується на одній речі. Зв'язок - це ступінь, до якого компонент / модуль підключається до інших модулів.

