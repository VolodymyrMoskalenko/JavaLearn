1. Для чого призначений Collections Framework?
Java Collections Framework - набір зв'язаних класів та інтерфейсів, які реалізують commonly reusable collection структур даних.Він був вперше спроектований і розроблений Джошуа Блохом.
Фреймворк був розроблений для досягнення таких цілей, як:
Фреймворк повинен бути високопродуктивний. Реалізації фундаментальних колекцій (динамічні масиви, зв'язані списки, дерева та хеш-таблиці) повинні бути високоефективними.
Система повинна дозволяти різним типам колекцій працювати аналогічним чином і з високим ступенем взаємодії.
Фреймворк має легко поширювати та / або адаптувати колекцію.
Майже всі колекції породжуються інтерфейсом java.util.Collection, який визначає основну структуру всіх колекцій. Його методи: add() - додавання елементу до колекції, remove() - видалення елементу з колекції, toArray() - повертає масив елементів, які є в колекції, contains() - перевіряє наявність заданого елементу в колекції та інші. Інтерфейс Collection успадковується від інтерфейсу java.lang.Iterable

Інтерфейс List
В JCF списки реалізуються через інтерфейс java.util.List. Два конкретних класи імплементують List. 
Перший java.util.ArrayList ,який реалізує список на основі масиву. Другий java.util.LinkedList ,
який реалізує java.util.List ,як двоз'язний список.
Інтерфейс Set
Інтерфейс java.util.Set реалізує концепцію множини.
Множина не може містити двох і більше одникових елементів, тобто всі елементи,які містяться в множині
є унікальними. Також множина не встановлює порядок. Set імплементується java.util.HashSet,
java.util.LinkedHashSet і java.util.TreeSet.

2. В чому полягає різниця між масивами та колекціями?
Маси́в — впорядкований набір фіксованої кількості однотипних елементів, що зберігаються в послідовно
розташованих комірках оперативної пам'яті, мають порядковий номер і спільне ім'я, що надає користувач.
В програмуванні масив (англ. array) — сукупність елементів одного типу даних, впорядкованих за індексами, які зазвичай репрезентовані натуральними числами, що визначають положення елемента в масиві.
Масив може бути одновимірним (вектором), та багатовимірним (наприклад, двовимірною таблицею),
тобто таким, де індексом є не одне число, а кортеж (сукупність) з декількох чисел, кількість 
яких збігається з розмірністю масиву.
При об’єктно орієнтованому програмуванні доводиться працювати з великою кількістю об’єктів. 
Зручно мати засоби групування об’єктів. 
Для цих цілей в Java розроблено набір інтерфейсів і класів на їх основі під назвою колекції . 

3. Які особливі властивості є у списків порівняно з іншими типами колекцій?
Список зберігає елементи в порядку в якому вони додавались.
Ми можемо отримати доступ до елементав списку по індексу.
Індекси стартують з 0.
Є декілька варіантів імплементацій інтерфейсу списків: ArrayList, LinkedList, Vector.
Додають нові методи add(),get(),indexOf(),remove().

4. Чим списки відрізняються від масивів?
Масив - це сукупність однотипних даних, розташованих безперервно в пам'яті. Доступ до елементу 
здійснюється за індексом за O (1) - ми звертаємося безпосередньо до потрібної ділянки пам'яті.
Доступ до елементу в зв'язковому списку в середньому займає O (N) шляхом перебору елементів в пошуках 
потрібного.Плюси легко видаляти і додавати елементи. Способи доступу до елементів відрізняються по 
реалізації і від мови програмування.
Наприклад, на Java в стандартному класі LinkedList в залежності від ситуації прохід елементів може
починатися як з початку, так і з кінця списку. І пошук елемента може здійснюватися як за індексом,
так і в порівнянні елементів.
Розмір фіксований, змінюваний: масив (array)
Розмір не фіксований, змінюваний: список (list)

5. Чим ArrayList відрізняється від LinkedList? Який з них у яких випадках краще використовувати?
ArrayList:
 1) Проста реалізація списку на основі масиву (ArrayList внутрішньо використовує динамічний масив для зберігання елементів.)
 2) Лінійна швидкість пошуку - O (n)
    Мементальне отримання за індексом - O (1)
    Додавання (вставлення в кінці) елементів нестабільне. Може бути миттєвим (O (1)), 
    але якщо є необхідність зміни масиву, то він зростає до O (n)
    Введення в середину та видалення відбувається повільніше. Нам потрібно скопіювати частину масиву 
   (O (довжина)) для зменшення. (Маніпуляція з ArrayList повільна, оскільки вона внутрішньо використовує масив. Якщо будь-який елемент видаляється з масиву, всі біти зміщуються в пам'яті.)
 3) Клас ArrayList може виступати як список лише тому, що він реалізує лише список.
 4) ArrayList кращий для зберігання та доступу до даних.
LinkedList
 1) LinkedList внутрішньо використовує подвійно пов'язаний список для зберігання елементів.
 2) Лінійний пошук та отримання за індексом - O (n)
    Мементальне додавання, вставлення та видалення - O (1)
    Маніпуляція за допомогою LinkedList швидше, ніж ArrayList, оскільки він використовує подвійно пов'язаний список,
    тому що в пам'яті не потрібно змінювати біти.
 3)	Клас LinkedList може виконувати функції списку та черги, оскільки він реалізує інтерфейси List та Deque.
 4) LinkedList краще для маніпулювання даними.
 
6. Що таке Iterator? В чому полягають переваги використання ітератора у порівнянні з класичним циклом ”for(int i=0; i<collection.size(); i++) { /* ... */  }”?
Ітератор - це інтерфейс, який використовується замість циклів у Java Collection Framework.
Більше того, ітератор відрізняється від циклів двома способами:
  Ітератор дозволяє  видаляти задані елементи із зазначеної колекції під час ітерації елементів.
  Назви методів були вдосконалені.
  Методи:
	forEachRemaining(Consumer<? super E>action) 
	Виконує задану дію на кожному елементі до тих пір, поки всі елементи не будуть оброблені або, якщо дія не буде викинуто виняток

	hasNext()
	Повертає true , якщо під час ітерації зустрічається більша кількість елементів.
	
	next()
	Повертає наступний вказаний елемент під час ітерації.
	
	remove()
	Вилучає останній елемент із колекції, передбачений ітератором.
	
7. Що таке типізовані та нетипізовані колекції (generic and non-generic)?
	Програми, що використовують Generics, отримали багато переваг порівняно з non-generics кодом.
	Повторне використання коду: Використовуючи Generics, потрібно написати метод / клас / інтерфейс лише один раз
	і використовувати для будь-якого типу. В той час, як у негенеріальній формі, код потрібно писати знову і знову,
	коли це потрібно.
	Безпека типу: Generics робить помилки, щоб відображати під час компіляції, ніж під час виконання 
	(Завжди краще знати проблеми у вашому коді під час компіляції, а не робити код невдалим під час виконання).
     Наприклад: Щоб створити ArrayList, який зберігає ім'я студентів, і якщо помилково програміст додає
	 цілий об'єкт замість рядка, компілятор дозволяє це. Але, коли ці дані витягнуті з ArrayList, це
	 спричинить проблеми під час виконання для non-generic ArrayList.
import java.util.*; 
  
class Test { 
    public static void main(String[] args) 
    { 
        // Creating an ArrayList without any type specified 
        ArrayList al = new ArrayList(); 
  
        al.add("Sachin"); 
        al.add("Rahul"); 
        al.add(10); // Compiler allows this 
  
        String s1 = (String)al.get(0); 
        String s2 = (String)al.get(1); 
  
        try { 
            // Causes Runtime Exception 
            String s3 = (String)al.get(2); 
        } 
        catch (Exception e) { 
            System.out.println("Exception: " + e); 
        } 
    } 
} 
Output:

Exception:
 java.lang.ClassCastException:
 java.lang.Integer cannot be cast to java.lang.String
 
Як генерики вирішують цю проблему: Якщо цей список був зроблений загальним,
 то він займе лише об'єкти String і кине Compile Time Error у будь-якому іншому випадку.
/ Using generics converts run time exceptions into 
// compile time errors 
  
import java.util.*; 
  
class Test { 
    public static void main(String[] args) 
    { 
        // Creating an ArrayList with String specified 
        ArrayList<String> al = new ArrayList<String>(); 
  
        al.add("Sachin"); 
        al.add("Rahul"); 
  
        // Now Compiler doesn't allow this 
        al.add(10); 
  
        String s1 = al.get(0); 
        String s2 = al.get(1); 
        String s3 = al.get(2); 
    } 
} 
Output:

15: error: no suitable method found for add(int)
        al.add(10); 

Кастинг індивідуального типу не потрібен: якщо Generics не потрібен, то у наведеному вище 
прикладі кожен раз, коли дані слід отримувати з ArrayList, їх потрібно кастувати.
Кастувати при кожній операції пошуку - це головний біль. Цього можна уникнути, 
якщо якимось чином уже відомо, що список містить лише String.
Наприклад:          
		import java.util.*; 
  
class Test { 
    public static void main(String[] args) 
    { 
        // Creating an ArrayList without any type specified 
        ArrayList al = new ArrayList(); 
  
        al.add("Sachin"); 
        al.add("Rahul"); 
  
        // For every retrieval, 
        // it needs to be casted to String for use 
        String s1 = (String)al.get(0); 
        String s2 = (String)al.get(1); 
    } 
} 
Як дженерики вирішують цю проблему: Якщо цей список був зроблений дженеріком, то він брав би лише 
об'єкти String і повертав би лише об'єкт String під час пошуку. І, отже, індивідуальне кастування не
обов'язкове.
  // A Simple Java program to demonstrate that 
// type casting is not needed in Generic 
  
import java.util.*; 
  
class Test { 
    public static void main(String[] args) 
    { 
        // Creating an ArrayList with String specified 
        ArrayList<String> al = new ArrayList<String>(); 
  
        al.add("Sachin"); 
        al.add("Rahul"); 
  
        // Retrieval can be easily 
        // without the trouble of casting 
        String s1 = al.get(0); 
        String s2 = al.get(1); 
    } 
} 
Впровадження загальних алгоритмів: Використовуючи дженерики, можна реалізувати алгоритми,
 які працюють над різними типами об'єктів, і при цьому вони також є безпечними.
BASIS  			NON-GENERIC COLLECTION																				GENERIC COLLECTION
Syntax		ArrayList list = new ArrayList();																ArrayList list = new ArrayList();
Type-safety	Can hold any type of data. Hence not type-safe.	   										Can hold only the defined type of data. Hence type safe.
Type casting	Individual type casting needs to be done at every retrieval.									No type casting is needed.
Compile-Time Checking	Checked for type safety at runtime.												Checked for type safety at Compile-time.

8. Для чого потрібен інтерфейс RandomAccess?
public interface RandomAccess
Інтерфейс маркера, який використовується реалізацією списку для вказівки, що вони підтримують
 швидкий (як правило, постійний час) випадковий доступ. Основна мета цього інтерфейсу 
 - дозволити загальним алгоритмам змінити свою поведінку, щоб забезпечити хорошу ефективність при 
 застосуванні до випадкових або послідовних списків доступу.
Найкращі алгоритми для управління списками випадкового доступу (наприклад, ArrayList) можуть створювати
 квадратичну поведінку при застосуванні до списків послідовного доступу (наприклад, LinkedList).
 Загальні алгоритми списку рекомендуються перевірити, чи даний список є екземпляром цього інтерфейсу,
 перш ніж застосовувати алгоритм, який забезпечив би низьку продуктивність, якщо він застосовувався до
 списку послідовного доступу, а також змінити їх поведінку, якщо необхідно, щоб гарантувати прийнятну
 продуктивність.
Визнано, що різниця між випадковим та послідовним доступом часто нечітка. Наприклад, деякі реалізації
 Списку забезпечують асимптотично лінійні часи доступу, якщо вони отримують величезні, але постійні часи 
 доступу на практиці. Така реалізація списку зазвичай повинна реалізовувати цей інтерфейс. Як правило,
 реалізація List має реалізувати цей інтерфейс, якщо для типових примірників класу цей цикл:
 for (int i=0, n=list.size(); i < n; i++)
         list.get(i);
 
runs faster than this loop:
     for (Iterator i=list.iterator(); i.hasNext(); )
         i.next();
 

9. Чим Collection відрізняється від Collections?
Колекція - це інтерфейс кореневого рівня Java Collection Framework. Більшість класів Java Collection Framework
 успадковує цей інтерфейс. Список, Набір та Черга - основні підрозділи цього інтерфейсу. JDK не надає жодних
 прямих реалізацій цього інтерфейсу. Але JDK забезпечує пряму реалізацію своїх підінтерфейсів. ArrayList,
 Vector, HashSet, LinkedHashSet, PriorityQueue - це деякі непрямі реалізації інтерфейсу Collection. Інтерфейс
 карт, який також є частиною системи колекції Java, не успадковує від колекції інтерфейс. Інтерфейс колекції
 є членом пакету java.util.
Колекції - клас utility в пакеті java.util. Він складається лише з статичних методів, які використовуються 
для роботи з об'єктами типу Колекція. Наприклад, у нього є метод пошуку максимального елемента в колекції, 
у нього є метод сортування колекції, у нього є спосіб пошуку певного елемента в колекції. Нижче наведено
 список деяких важливих методів класу Collections.