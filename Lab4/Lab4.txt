1.Масиви призначені для зберігання великої кількості однотипних даних:
• В Java масиви є об’єктами
• як усі об’єкти зберігаються у купі (heap)
• ім’я масиву = посилання на масив
• масиви мають поле length (read-only) та методи (від Object)

Змінна є примітивом, містить одне значення і зберігається в стеку ( якщо вкладені в обєкт, то в купі).

2.Стек- це  різновид лінійного списку, структура даних, яка працює за принципом (дисципліною) «останнім прийшов — першим пішов» (LIFO, англ. last in, first out). Всі операції (наприклад, видалення елементу) в стеку можна проводити тільки з одним елементом, який знаходиться на верхівці стека та був введений в стек останнім.
 Дві базові операції: – PUSH  – POP
Для чого потрібен стек?
• Передача параметрів у метод
• Запис адреси повернення з метода
• Пам’ять під локальні змінні метода
• В стеку можуть зберігатися лише примітиви та посилання на об’єкти

Купа (англ. heap) в інформатиці — спеціалізована деревовидна структура даних, в якій існують певні властивості впорядкованості: якщо В — вузол нащадок A — тоді ключ(A) ≥ ключ(B). З цього випливає, що елемент з найбільшим ключем завжди є кореневим вузлом. Не існує ніяких обмежень щодо максимальної кількості елементів-нащадків повинна мати кожна ланка, однак, на практиці, зазвичай, кожен елемент має не більше двох нащадків.
Куча-це динамічно розподілювана пам'ять
• у купі можна зберігати лише об’єкти
• Виділяємо пам’ять та створюємо об’єкти за допомогою оператора new
• «В ручну» очищати пам’ять в Java не потрібно

3.Змінні зберігаються у стеку, безпосередньо у купі не може, тільки в складі обєкту в купі.
Масив знаходиться в купі беспосередньо, не може знаходитись в стеку, може знаходитись в обєкті в купі, посилаючись на специфікацію https://docs.oracle.com/javase/specs/jls/se8/html/jls-10.html

4.Імя масиву - це посилання на массив, що зберігає адрес обєкту массиву, присваювання одному посиланню на масив іншому, це не копіювання масивів, а копіювання посилань на обєкти.
Масив - це обєкт для зберігання великої кількості однотипних данних.
Посилання на масив знаходиться в стеку, безпосередньо у купі не може, тільки в складі обєкту в купі.

5.Перший елемент має індекс 0 , а останній 9.

6.Якщо спробувати звернутись до неіснуючої комірки у масиві, буде викинуто IndexOutOfBoundsException.

7.При створенні нового масиву без явної ініціалізації усі його комірки будуть проініціалізовані
0 – для чисел
false – для boolean
null – для посилань на об’єкти


8. Перша комірка масиву [0], остання комірка масиву має [length-1]

9.Розмір масиву змінити неможна, але можна створити новий масив іншого розміру, скопіювати в нього дані і використовувати посилання на нього замість посилання на старий масив

10. При копіюванні посилання на масив, одній змінній що посилається на масив, іншій зміній означає, що обидві змінні посилаються на один і той самий масив. Так так як масив - це обєкт.
Це присваювання не приводить до створення копії масиву або копіювання змісту одного масиву в інший.

11.При втрачанні усіх посилань на масив він видаляється за допомогою garbage collector.

12.for-each це спрощена форма циклу for для послідовного перебору кожного елементу.
Цикл for можна модифікувати і мати більшу варіативність.

13.В першому варіанті: цілочисельний тип буде приведений до double. 
В другому варіанті: error: incompatible types: possible lossy conversion from double to int



