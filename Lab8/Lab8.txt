1.Що таке конструктор? Для чого вони використовуються?
Конструктор - це метод класу, який ініціалізує новий об'єкт після його створення.
 Ім'я конструктора завжди збігається з ім'ям класу, в якому він розташований. 
У конструкторів немає типу повертається результату - ніякого, навіть void.
В одному класі може бути відразу кілька конструкторів, поетом при створенні об'єкта ми можемо передавати
 різну кількість параметрів і різний тип параметрів.
 Компілятор сам визначає який конструктор необхідно використовувати в залежності від переданих параметрів.
 
2. Що таке перевантаження (overloading) та заміщення(overriding)? Яка між ними різниця? 
Чи можна виконати перевантаження та заміщення одночасно?
Метод Перевантаження - це поліморфізм у часі. У перевантаженні методу більше одного методу поділяє одне 
і те ж ім'я методу з різною сигнатурою у класі. У перевантаженні методу тип повернення може бути або не може
бути однаковим, але нам потрібно змінити параметр(и), оскільки в java ми не можемо досягти перевантаження методу, 
змінивши лише тип повернення методу.

Метод заміщення - це поліморфізм часу виконання. У методу заміщення похідний клас забезпечує 
конкретну реалізацію методу, який вже надається базовим класом або батьківським класом. 
У способі заміщення тип повернення повинен бути однаковим або ко-варіантом (тип повернення може 
змінюватися в тому ж напрямку, що і похідний клас).
Так, можна виконати одночасно.

3. Що так immutable об’єкти? Які є переваги immutable у порівнянні з mutable об’єктами?
Immutable об'єкт - це об'єкт, стан якого після створення неможливо змінити.
 У разі Java це значить що всі поля екземпляра у клас відзначені як final і є примітивами
 або теж immutable типами.

приклад:

public class ImmutablePoint {
    private final int x;
    private final int y;
    private final String description;

    public ImmutablePoint (int x, int y, String description) {
        this.x = x;
        this.y = y;
        this.description = description;
    }
}
Після створення екземпляра ImmutablePoint його модифікація неможлива.

Найпростіший приклад immutable класу з JDK це String. Будь-які методи, які ви викличте на рядку 
(наприклад description.toLowerCase ()) повернуть новий рядок, а не модифікують вихідну.

Приклад mutable клас з JDK - Date. Наприклад myDate.setHours (x) модифікує сам екземпляр myDate!

У разі многопоточного програмування переваги immutable класів очевидні: після створення 
об'єкти можна передавати іншим потокам і вони завжди будуть в актуальному стані. 
Тобто вам не треба перевіряти не застаріло чи стан вашого примірника і не модифікував його
 інший потік поки ви з ним працюєте. Наприклад, у вас є метод bill (Date endDate), в ньому ви наївно 
 перевіряєте відповідність endDate якимось попереднім умовам і починаєте з нею працювати. 
 У цей момент інший потік може змінити endDate, наприклад встановить її глибоко в минуле.
 Наслідки можуть бути самими дивовижними.
 
4. Які переваги використання гетерів та сетерів у порівнянні з прямим доступом до змінних стану об’єктів?
Це один з видів реалізації інкапсуляції, бо в сетерах ти приховуєш логіку ініціалізації змінних чи логіку
зміни обєкту. Сеттер не завжди просто займається присваюванням змінної, в сеттері можна перевірити чи
обєкт не пустий, як присваюється, чи відповідає він правилам бізнес-догіки, чи можете змінити значення
інших зміннних. Ти самим обєкт захищає себе від знаходження в некоректному стані. При наявності відкритої
змінної і без гетерів/сетерів це досить складно. Відкриті поля підходять в обєктах переносу данних dto, в
яких взагалі відсутня бізнес-догіка.

5. У якій послідовності викликаються конструктори нащадка та суперкласів?

В ієрархії класів конструктори викликаються в порядку спадкування, починаючи з суперкласу і закінчуючи подклассом.
Більшетого, цей порядок залишається незмінним незалежно від того, використовується форма super () чи ні, оскільки виклик методу super () повинен бути в першому операторі, що виконується в конструкторі підкласу.

Якщо метод super () не викликається, то використовується конструктор за замовчуванням або ж конструктор без параметровіз кожного суперкласу.

У наступному прикладі програми демонструється порядок виклику і виконання конструкторів:

class AA {
    AA () {
        System.out.println ( "AA.");
    }
}
class BB extends AA {
    BB () {
        System.out.println ( "BB.");
    }
}
class CC extends BB {

    CC () {
        System.out.println ( "CC.");
    }
}
class DD extends CC {

    DD () {
        System.out.println ( "DD.");
    }
}
class ConstructorCall {
    public static void main (String args []) {
        DD dd = new DD ();
    }
}

Програма виводить наступний результат:

pro-java.ru@admin: ~ $ javac constructor.java
pro-java.ru@admin: ~ $ java ConstructorCall
  AA.
  BB.
  CC.
  DD.
pro-java.ru@admin: ~ $
Як бачите, конструктори викликаються в порядку спадкування. 
По зрілому міркуванні стає ясно, що виконання конструкторів в порядку спадкування має певний сенс.
Суперкласу нічого невідомо про своїх підкласах, і тому будь-яка ініціалізація повинна 
бути виконана в ньому незалежно від будь-якої ініціалізації, виконуваної підклассом. 
Отже, вона повинна виконуватися в першу чергу.

6. Що таке статичний (static block) та динамічний блоки (instance block) ініціалізації? При яких умовах вони запускаються?
static block
Щоб визначити блок статичної ініціалізації, ми використовуємо ключове слово static.
Блок статичної ініціалізації завантажується, як тільки клас завантажується, 
і він не пов'язаний з викликом конструктору класу для створення об'єкта.
Статичний блок може отримати доступ лише до статичних змінних та статичних методів свого класу.
Немає автоматичного виклику конструктора суперкласу з блоку статичної ініціалізації.
Статичний блок викликається лише один раз протягом усього виконання програми при завантаженні класу.

instance block
Для визначення блоку ініціалізації екземпляра не потрібне ключове слово
Динамічний блок ініціалізації екземпляра виконується лише тоді, коли викликається конструктор
для створення об’єкта.
An instance initialization block can not only access static variables and static methods but also
instance variables and instance methods of the class.
Блок ініціалізації екземпляра завжди робить автоматичний виклик до конструктора суперкласу 
за допомогою виклику super () перед виконанням будь-якого іншого оператора в ньому.
Блок ініціалізації екземплярів може запускатися багато разів, тоді коли є виклик конструктору класу.